import "./chunk-DWA4UIM3.js";

// node_modules/vue3-lazyload/dist/vue3-lazyload.esm.js
var LifecycleEnum;
(function(LifecycleEnum2) {
  LifecycleEnum2["LOADING"] = "loading";
  LifecycleEnum2["LOADED"] = "loaded";
  LifecycleEnum2["ERROR"] = "error";
})(LifecycleEnum || (LifecycleEnum = {}));
var inBrowser = typeof window !== "undefined" && window !== null;
var hasIntersectionObserver = checkIntersectionObserver();
var isEnumerable = Object.prototype.propertyIsEnumerable;
var getSymbols = Object.getOwnPropertySymbols;
function isObject(val) {
  return typeof val === "function" || toString.call(val) === "[object Object]";
}
function isPrimitive(val) {
  return typeof val === "object" ? val === null : typeof val !== "function";
}
function isValidKey(key) {
  return key !== "__proto__" && key !== "constructor" && key !== "prototype";
}
function checkIntersectionObserver() {
  if (inBrowser && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function() {
          return this.intersectionRatio > 0;
        }
      });
    }
    return true;
  }
  return false;
}
function assignSymbols(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (!isObject(target)) {
    throw new TypeError("expected the first argument to be an object");
  }
  if (args.length === 0 || typeof Symbol !== "function" || typeof getSymbols !== "function") {
    return target;
  }
  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
    var arg = args_1[_a];
    var names = getSymbols(arg);
    for (var _b = 0, names_1 = names; _b < names_1.length; _b++) {
      var key = names_1[_b];
      if (isEnumerable.call(arg, key)) {
        target[key] = arg[key];
      }
    }
  }
  return target;
}
function assign(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var i = 0;
  if (isPrimitive(target))
    target = args[i++];
  if (!target)
    target = {};
  for (; i < args.length; i++) {
    if (isObject(args[i])) {
      for (var _a = 0, _b = Object.keys(args[i]); _a < _b.length; _a++) {
        var key = _b[_a];
        if (isValidKey(key)) {
          if (isObject(target[key]) && isObject(args[i][key])) {
            assign(target[key], args[i][key]);
          } else {
            target[key] = args[i][key];
          }
        }
      }
      assignSymbols(target, args[i]);
    }
  }
  return target;
}
var DEFAULT_OBSERVER_OPTIONS = {
  rootMargin: "0px",
  threshold: 0
};
var DEFAULT_LOADING = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var DEFAULT_ERROR = "";
var Lazy = (
  /** @class */
  function() {
    function Lazy2(options) {
      this.options = {
        loading: DEFAULT_LOADING,
        error: DEFAULT_ERROR,
        observerOptions: DEFAULT_OBSERVER_OPTIONS,
        log: true,
        lifecycle: {}
      };
      this._images = /* @__PURE__ */ new WeakMap();
      this.config(options);
    }
    Lazy2.prototype.config = function(options) {
      if (options === void 0) {
        options = {};
      }
      assign(this.options, options);
    };
    Lazy2.prototype.mount = function(el, binding) {
      var _a = this._valueFormatter(binding.value), src = _a.src, loading = _a.loading, error = _a.error, lifecycle = _a.lifecycle;
      this._lifecycle(LifecycleEnum.LOADING, lifecycle, el);
      el.setAttribute("src", loading || DEFAULT_LOADING);
      if (!hasIntersectionObserver) {
        this.loadImages(el, src, error, lifecycle);
        this._log(function() {
          throw new Error("Not support IntersectionObserver!");
        });
      }
      this._initIntersectionObserver(el, src, error, lifecycle);
    };
    Lazy2.prototype.update = function(el, binding) {
      var _a;
      (_a = this._realObserver(el)) === null || _a === void 0 ? void 0 : _a.unobserve(el);
      var _b = this._valueFormatter(binding.value), src = _b.src, error = _b.error, lifecycle = _b.lifecycle;
      this._initIntersectionObserver(el, src, error, lifecycle);
    };
    Lazy2.prototype.unmount = function(el) {
      var _a;
      (_a = this._realObserver(el)) === null || _a === void 0 ? void 0 : _a.unobserve(el);
      this._images.delete(el);
    };
    Lazy2.prototype.loadImages = function(el, src, error, lifecycle) {
      this._setImageSrc(el, src, error, lifecycle);
    };
    Lazy2.prototype._setImageSrc = function(el, src, error, lifecycle) {
      var _this = this;
      if ("img" === el.tagName.toLowerCase()) {
        if (src) {
          var preSrc = el.getAttribute("src");
          if (preSrc !== src) {
            el.setAttribute("src", src);
          }
        }
        this._listenImageStatus(el, function() {
          _this._lifecycle(LifecycleEnum.LOADED, lifecycle, el);
        }, function() {
          var _a;
          el.onload = null;
          _this._lifecycle(LifecycleEnum.ERROR, lifecycle, el);
          (_a = _this._realObserver(el)) === null || _a === void 0 ? void 0 : _a.disconnect();
          if (error)
            el.setAttribute("src", error);
          _this._log(function() {
            throw new Error("Image failed to load!");
          });
        });
      } else {
        el.style.backgroundImage = "url('" + src + "')";
      }
    };
    Lazy2.prototype._initIntersectionObserver = function(el, src, error, lifecycle) {
      var _this = this;
      var _a;
      var observerOptions = this.options.observerOptions;
      this._images.set(el, new IntersectionObserver(function(entries) {
        Array.prototype.forEach.call(entries, function(entry) {
          var _a2;
          if (entry.isIntersecting) {
            (_a2 = _this._realObserver(el)) === null || _a2 === void 0 ? void 0 : _a2.unobserve(entry.target);
            _this._setImageSrc(el, src, error, lifecycle);
          }
        });
      }, observerOptions));
      (_a = this._realObserver(el)) === null || _a === void 0 ? void 0 : _a.observe(el);
    };
    Lazy2.prototype._listenImageStatus = function(image, success, error) {
      image.onload = success;
      image.onerror = error;
    };
    Lazy2.prototype._valueFormatter = function(value) {
      var src = value;
      var loading = this.options.loading;
      var error = this.options.error;
      var lifecycle = this.options.lifecycle;
      if (isObject(value)) {
        src = value.src;
        loading = value.loading || this.options.loading;
        error = value.error || this.options.error;
        lifecycle = value.lifecycle || this.options.lifecycle;
      }
      return {
        src,
        loading,
        error,
        lifecycle
      };
    };
    Lazy2.prototype._log = function(callback) {
      if (this.options.log) {
        callback();
      }
    };
    Lazy2.prototype._lifecycle = function(life, lifecycle, el) {
      switch (life) {
        case LifecycleEnum.LOADING:
          el === null || el === void 0 ? void 0 : el.setAttribute("lazy", LifecycleEnum.LOADING);
          if (lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.loading) {
            lifecycle.loading(el);
          }
          break;
        case LifecycleEnum.LOADED:
          el === null || el === void 0 ? void 0 : el.setAttribute("lazy", LifecycleEnum.LOADED);
          if (lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.loaded) {
            lifecycle.loaded(el);
          }
          break;
        case LifecycleEnum.ERROR:
          el === null || el === void 0 ? void 0 : el.setAttribute("lazy", LifecycleEnum.ERROR);
          if (lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.error) {
            lifecycle.error(el);
          }
          break;
      }
    };
    Lazy2.prototype._realObserver = function(el) {
      return this._images.get(el);
    };
    return Lazy2;
  }()
);
var index = {
  /**
   * install plugin
   *
   * @param {App} Vue
   * @param {LazyOptions} options
   */
  install: function(Vue, options) {
    var lazy = new Lazy(options);
    Vue.config.globalProperties.$Lazyload = lazy;
    Vue.provide("Lazyload", lazy);
    Vue.directive("lazy", {
      mounted: lazy.mount.bind(lazy),
      updated: lazy.update.bind(lazy),
      unmounted: lazy.unmount.bind(lazy)
    });
  }
};
export {
  index as default
};
/*! Bundled license information:

vue3-lazyload/dist/vue3-lazyload.esm.js:
  (*!
   * Vue3-Lazyload.js v0.2.5-beta
   * A Vue3.x image lazyload plugin
   * (c) 2021 MuRong <admin@imuboy.cn>
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=vue3-lazyload.js.map
